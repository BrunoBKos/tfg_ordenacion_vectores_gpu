#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <omp.h>
#include <math.h>
#include <thrust/sort.h>
#include <thrust/execution_policy.h>
#include "common.h"
#include <sys/time.h>
#include <cub/device/device_segmented_radix_sort.cuh>

#include <moderngpu/kernel_segsort.hxx>
#include <moderngpu/context.hxx>
#include <vector>
#include <iostream>

#include "../bb_segsort/bb_segsort.h"

///////////
// Declaraci√≥n de Constantes
///////////

using namespace mgpu;

#define n_arrays 200
#define ELEMS 27400


int main(int argc, char** argv) {

    struct timeval tv_start, tv_end;
    double run_time;

    float* vector;
    float* sorted_vector_sec;
    float* sorted_vector_par;

    // host reserves
    vector = (float*) malloc(n_arrays*ELEMS*sizeof(float));
    sorted_vector_sec = (float*) malloc(n_arrays*ELEMS*sizeof(float));
    sorted_vector_par = (float*) malloc(n_arrays*ELEMS*sizeof(float));

    // Vector Initizalize
    printf("Vector Initialize\n");
    gettimeofday(&tv_start, NULL);
    initialize_vector_f32(vector, n_arrays*ELEMS);
    gettimeofday(&tv_end, NULL);
    run_time=(tv_end.tv_sec - tv_start.tv_sec) * 1000000 + (tv_end.tv_usec - tv_start.tv_usec); //useconds
    run_time /= 1000000; // seconds
    printf("TIme in seconds after the initialization of the input vectors: %lg \n", run_time);
    printf("-----------------------------------\n");

    // OpenMP EXECUTION
    printf("Ejecucion paralela con openmp y thrust en CPU\n");
    gettimeofday(&tv_start, NULL);
    #pragma omp parallel 
    {
        float* output;
        #pragma omp for
        for(int j = 0; j < n_arrays; j++) {
            output = sorted_vector_sec + (j*ELEMS);
            memcpy(output, vector+(j*ELEMS), ELEMS*sizeof(float)); // copy of the original array
            thrust::sort(thrust::host, output, output+ELEMS); // sorting
        }
        #pragma omp barrier
    }
    gettimeofday(&tv_end, NULL);
    run_time=(tv_end.tv_sec - tv_start.tv_sec) * 1000000 + (tv_end.tv_usec - tv_start.tv_usec); //useconds
    run_time /= 1000000; // seconds
    printf("TIme in seconds after the openmp sorting execution: %lg \n", run_time);
    printf("-----------------------------------\n");

    /* EJECUCION PARALELA VERSION BACK TO BACK CON CUB DEVICE RADIX SORT PAIRS EN GPU */
    printf("Ejecucion paralela version back to back con device radix sort pairs en GPU\n");
    gettimeofday(&tv_start, NULL); 
    {
        float* output;
        float* d_input;
        float* d_output;
        int* h_keys;
        int* d_keys_in;
        int* d_keys_out;

        void* d_temp_storage_1 = NULL;
        void* d_temp_storage_2 = NULL;
        size_t temp_storage_bytes = 0;

        output = (float*) malloc(n_arrays*ELEMS*sizeof(float));
        h_keys = (int*) malloc(n_arrays*ELEMS*sizeof(int));
        cudaMalloc(&d_input, n_arrays*ELEMS*sizeof(float));
        cudaMalloc(&d_output, n_arrays*ELEMS*sizeof(float));
        cudaMalloc(&d_keys_in, n_arrays*ELEMS*sizeof(int));
        cudaMalloc(&d_keys_out, n_arrays*ELEMS*sizeof(int));

        for(int i = 0; i < n_arrays; i++) memset(h_keys+(i*ELEMS), i, ELEMS);

        cub::DeviceRadixSort::SortPairs(d_temp_storage_1, temp_storage_bytes, d_input, d_output, d_keys_in, d_keys_out, n_arrays*ELEMS);
        // Allocate temporary storage
        cudaMalloc(&d_temp_storage_1, temp_storage_bytes);

        cub::DeviceRadixSort::SortPairs(d_temp_storage_2, temp_storage_bytes, d_keys_in, d_keys_out, d_input, d_output, n_arrays*ELEMS);
        // Allocate temporary storage
        cudaMalloc(&d_temp_storage_2, temp_storage_bytes);

        cudaMemcpy(d_input, vector, n_arrays*ELEMS*sizeof(float), cudaMemcpyHostToDevice);
        cudaMemcpy(d_keys_in, h_keys, n_arrays*ELEMS*sizeof(int), cudaMemcpyHostToDevice);
        cub::DeviceRadixSort::SortPairs(d_temp_storage_1, temp_storage_bytes, d_input, d_output, d_keys_in, d_keys_out, n_arrays*ELEMS);
        cudaMemcpy(output, d_output, n_arrays*ELEMS*sizeof(float), cudaMemcpyDeviceToHost);
        cudaMemcpy(h_keys, d_keys_out, n_arrays*ELEMS*sizeof(int), cudaMemcpyDeviceToHost);

        cudaMemcpy(d_input, output, n_arrays*ELEMS*sizeof(float), cudaMemcpyHostToDevice);
        cudaMemcpy(d_keys_in, h_keys, n_arrays*ELEMS*sizeof(int), cudaMemcpyHostToDevice);
        cub::DeviceRadixSort::SortPairs(d_temp_storage_2, temp_storage_bytes, d_keys_in, d_keys_out, d_input, d_output, n_arrays*ELEMS);
        cudaMemcpy(output, d_output, n_arrays*ELEMS*sizeof(float), cudaMemcpyDeviceToHost);
        cudaMemcpy(h_keys, d_keys_out, n_arrays*ELEMS*sizeof(int), cudaMemcpyDeviceToHost);

        memcpy(sorted_vector_par, output, n_arrays*ELEMS*sizeof(float)); // copy of the original array

        free(output);
        cudaFree(d_input);
        cudaFree(d_output);
        cudaFree(d_keys_in);
        cudaFree(d_keys_out);

    }
    gettimeofday(&tv_end, NULL);
    run_time=(tv_end.tv_sec - tv_start.tv_sec) * 1000000 + (tv_end.tv_usec - tv_start.tv_usec); //useconds
    run_time /= 1000000; // seconds
    printf("Tiempo: %lg segundos\n", run_time);
    printf("-----------------------------------\n");

    int ret = memcmp(sorted_vector_sec, sorted_vector_par, n_arrays*ELEMS*sizeof(float));
    if(ret) printf("Error. Given value: %d\n", ret);
    else printf("Correcto\n");

    free(vector);
    free(sorted_vector_sec);
    free(sorted_vector_par);
    return 0;
}